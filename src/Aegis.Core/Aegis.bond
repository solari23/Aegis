import "bond/core/bond.bond"
namespace Aegis.Core

// SecureArchives store timestamps in unix epoch format.
using DateTime = int64;

// Aegis SecureArchive File Format (.ags)
// --------------------------------------
// Aegis SecureArchive files (extension: .ags) are binary files with contents in the format described below.
//
//  # | Bytes | Count    | Data Type | Contents
// ---+-------+----------+-----------+------------------------------------------------------------------------------
//  1 | 0..3  | 4 bytes  |   int32   | The little-endian file version. Currently always the constant value: 1
//  2 | 4..35 | 32 bytes |   byte[]  | The HMAC-256 of the serialized SecureArchive (field 3) using the archive key.
//  3 | 36..  | variable |   byte[]  | The serialized SecureArchive (bond) data structure (see schema below).

enum EncryptionAlgo
{
    Unknown = 0,
    Aes256Gcm,
}

enum KeyDerivationFunction
{
    Unknown = 0,
    PBKDF2 = 1,
}

// Container that packages encrypted data with an envelope describing the encryption used.
struct EncryptedPacket
{
    // The initialization vector for the encryption.
    0: vector<uint8> IV;

    // The authentication tag, for when authenticated encryption algorithms are used.
    1: vector<uint8> AuthTag;

    // The actual encrypted data.
    2: vector<uint8> CipherText;
}

// Metadata associated with user keys authorized to unlock the SecureArchive.
// User keys are derived from secrets input by the user at runtime to unlock the archive.
// The keys and their associated keyId are derived using key derivation functions.
// The algorithm is:
//   let N be the number of bytes for the key
//   let M be the number of bytes for the keyId
//   keyMatter := Derive N + M bytes from the secret using the KDF
//   key := keyMatter[0..N-1]
//   keyId := base64url(keyMatter[N..])
struct UserKeyAuthorization
{
    // A friendly name to help the user identify the key.
    0: string FriendlyName;

    // An identifier derived along with the key. It is the base64url encoding of some extra
    // bytes produced by the key derivation function while deriving the user key.
    // Matching on this value should *never* be used to positively authenticate a user.
    1: string KeyId;

    // Unix epoch timestamp of when the key was authorized.
    2: DateTime TimeAdded;

    // The archive key, encrypted by the authorized key.
    // Authenticated cyphers must also check integrity of Utf8Bytes(string.Concat(FriendlyName, KeyId))
    3: EncryptedPacket EncryptedArchiveKey;
}

// Metadata that describes security settings (e.g. crypto algorithm choice) for the archive.
struct SecuritySettings
{
    // The algorithm used to encrypt data in the archive.
    0: EncryptionAlgo EncryptionAlgo = Unknown;

    // The key derivation function (KDF) used to generate user keys.
    1: KeyDerivationFunction KeyDerivationFunction = Unknown;

    // The work factor parameter (e.g. iteration count) for the KDF.
    2: int32 KeyDerivationWorkFactor;

    // The size (in bytes) of KeyIds generated for user keys.
    3: int32 KeyIdSizeInBytes;
}

// Metadata about a file stored in the SecureArchive
struct FileIndexEntry
{
    // A unique identifier for the archive.
    0: bond.GUID FileId;

    // A virtual file name. These must be unique within the archive.
    1: string FileName;

    // When the file was added to the archive.
    3: DateTime AddedTime;

    // When the archived file was last modified.
    4: DateTime LastModifiedTime;

    // TODO: Store a SHA256 of the original file.
    // TODO: Implement file compression.
}

// The index of files stored in the SecureArchive.
struct FileIndex
{
    // The actual index entries, one entry per file stored in the SecureArchive.
    0: vector<FileIndexEntry> Entries;
}

// The core data structure that stores the user's encrypted documents and implements archive functionality.
struct SecureArchive
{
    // A unique identifier for the archive.
    0: bond.GUID Id;

    // The file version number for the archive.
    1: int32 FileVersion;

    // The security settings for the archive.
    2: SecuritySettings SecuritySettings;

    // When the archive was created.
    3: DateTime CreateTime;

    // When the archive was last modified.
    4: DateTime LastModifiedTime;

    // The salt used when deriving keys.
    5: vector<uint8> KeyDerivationSalt;

    // The archive ID encrypted with the archive key. This field is used to
    // test if the presented user key is authorized to unlock the archive.
    6: EncryptedPacket AuthCanary;

    // The list of keys that are authorized to unlock the archive.
    7: vector<UserKeyAuthorization> UserKeyAuthorizations;

    // The encrypted file index. The encrypted data's schema is of type FileIndex.
    8: EncryptedPacket EncryptedFileIndex;

    // TODO: The SecureArchive will also contain:
    //   - A map<Guid, EncryptedPacket> of file IDs to the actual encrypted files.
}