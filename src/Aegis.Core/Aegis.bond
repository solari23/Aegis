import "bond/core/bond.bond"
namespace Aegis.Core

// SecureArchives store timestamps in unix epoch format.
using DateTime = int64;

enum UserKeyType
{
    Unknown = 0,

    // The key is derived from a password entered by the user using the
    // PBKDF2 algorithm described in RFC 2898.
    PasswordDerivedKey,
}

enum EncryptionAlgo
{
    Unknown = 0,
    Aes256Gcm,
}

// Container that packages encrypted data with an envelope describing the encryption used.
struct EncryptedPacket
{
    // The initialization vector for the encryption.
    0: vector<uint8> IV;

    // The authentication tag, for when authenticated encryption algorithms are used.
    1: vector<uint8> AuthTag;

    // The actual encrypted data.
    2: vector<uint8> CipherText;
}

// Metadata associated with user keys authorized to unlock the SecureArchive.
// The actual key needs to be provided by user at runtime.
struct AuthorizedUserKey
{
    // The type of the key.
    0: UserKeyType KeyType = Unknown;

    // The base64url encoded SHA1 of the key, used solely as an identifier.
    // Matching on this value should *never* be used to authenticate a user.
    1: string KeyId;

    // Unix epoch timestamp of when the key was authorized.
    2: DateTime TimeAdded;

    // The salt used to generate derived key types.
    3: nullable<vector<uint8>> Salt = nothing;

    // The number of iterations used to generate derived key types.
    4: nullable<int32> IterationCount = nothing;

    // The archive key, encrypted by the authorized key.
    5: EncryptedPacket EncryptedArchiveKey;
}

// Defines the format of Aegis SecureArchive files.
struct SecureArchive
{
    // A unique identifier for the archive.
    0: bond.GUID Id;

    // The file version number for the archive.
    1: int32 FileVersion;

    // The algorithm used to encrypt data in the archive.
    2: EncryptionAlgo EncryptionAlgo = Unknown;

    // When the archive was created.
    3: DateTime CreateTime;

    // When the archive was last modified.
    4: DateTime LastModifiedTime;

    // The archive's Id encrypted with the archive key. This field is used to
    // check if the presented user key is authorized to unlock the archive.
    5: EncryptedPacket AuthCanary;

    // The list of keys that are authorized to unlock the archive.
    6: vector<AuthorizedUserKey> AuthorizedUserKeys;

    // TODO: The SecureArchive will also contain:
    //   - An EncryptedPacket index with metadata about the files. Files should have:
    //      - A friendly name (the original file name, may be extended to create virtual paths)
    //      - A Guid unique identifier
    //      - Sha256 of the file contents
    //   - A map<Guid, EncryptedPacket> of file IDs to the actual encrypted files. The encryption
    //     method should be authenticated (e.g. AES in GCM mode), and the encryption method should
    //     take the fileId into account to make sure it hasn't been tampered with as well.
}