import "bond/core/bond.bond"
namespace Aegis.Core

// SecureArchives store timestamps in unix epoch format.
using DateTime = int64;

enum EncryptionAlgo
{
    Unknown = 0,
    Aes256Gcm,
}

enum KeyDerivationFunction
{
    Unknown = 0,
    PBKDF2 = 1,
}

// Container that packages encrypted data with an envelope describing the encryption used.
struct EncryptedPacket
{
    // The initialization vector for the encryption.
    0: vector<uint8> IV;

    // The authentication tag, for when authenticated encryption algorithms are used.
    1: vector<uint8> AuthTag;

    // The actual encrypted data.
    2: vector<uint8> CipherText;
}

// Metadata associated with user keys authorized to unlock the SecureArchive.
// User keys are derived from secrets input by the user at runtime to unlock the archive.
// The keys and their associated keyId are derived using key derivation functions.
// The algorithm is:
//   let N be the number of bytes for the key
//   let M be the number of bytes for the keyId
//   keyMatter := Derive N + M bytes from the secret using the KDF
//   key := keyMatter[0..N-1]
//   keyId := base64url(keyMatter[N..])
struct UserKeyAuthorization
{
    // A friendly name to help the user identify the key.
    0: string FriendlyName;

    // An identifier derived along with the key. It is the base64url encoding of some extra
    // bytes produced by the key derivation function while deriving the user key.
    // Matching on this value should *never* be used to positively authenticate a user.
    1: string KeyId;

    // Unix epoch timestamp of when the key was authorized.
    2: DateTime TimeAdded;

    // The archive key, encrypted by the authorized key.
    // Authenticated cyphers must also check integrity of Utf8Bytes(string.Concat(FriendlyName, KeyId))
    3: EncryptedPacket EncryptedArchiveKey;
}

// Metadata that describes security settings (e.g. crypto algorithm choice) for the archive.
struct SecuritySettings
{
    // The algorithm used to encrypt data in the archive.
    0: EncryptionAlgo EncryptionAlgo = Unknown;

    // The key derivation function (KDF) used to generate user keys.
    1: KeyDerivationFunction KeyDerivationFunction = Unknown;

    // The work factor parameter (e.g. iteration count) for the KDF.
    2: int32 KeyDerivationWorkFactor;

    // The size (in bytes) of KeyIds generated for user keys.
    3: int32 KeyIdSizeInBytes;
}

// The core data structure that represents SecureArchive files. The SecureArchive is a
// self-contained file that holds the user's encrypted documents.
struct SecureArchive
{
    // A unique identifier for the archive.
    0: bond.GUID Id;

    // The file version number for the archive.
    1: int32 FileVersion;

    // The security settings for the archive.
    2: SecuritySettings SecuritySettings;

    // When the archive was created.
    3: DateTime CreateTime;

    // When the archive was last modified.
    4: DateTime LastModifiedTime;

    // The salt used when deriving keys.
    5: vector<uint8> KeyDerivationSalt;

    // The archive ID encrypted with the archive key. This field is used to
    // test if the presented user key is authorized to unlock the archive.
    6: EncryptedPacket AuthCanary;

    // The list of keys that are authorized to unlock the archive.
    7: vector<UserKeyAuthorization> UserKeyAuthorizations;

    // TODO: The SecureArchive will also contain:
    //   - An encrypted index with metadata about the files. Files should have:
    //      - A friendly name (the original file name, may be extended to create virtual paths)
    //      - A Guid unique identifier
    //      - A compression algorithm identifier, so we can compress files before encrypting
    //      - Sha256 of the file contents (used to check if checked out copies on disk are modified)
    //   - A map<Guid, EncryptedPacket> of file IDs to the actual encrypted files. The encryption
    //     method should be authenticated (e.g. AES in GCM mode), and the encryption method should
    //     take the fileId into account to make sure it hasn't been tampered with as well.
}